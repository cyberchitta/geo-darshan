<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Geo Darshan Viewer</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/georaster@1.6.0/dist/georaster.browser.bundle.min.js"></script>
  <script src="https://unpkg.com/georaster-layer-for-leaflet@3.10.0/dist/georaster-layer-for-leaflet.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
    }

    .viewer-container {
      width: 100%;
      height: 100vh;
      position: relative;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      font-size: 18px;
    }

    .loading-overlay.hidden {
      display: none;
    }

    .file-selector {
      text-align: center;
      padding: 20px;
    }

    .file-selector h3 {
      margin-bottom: 10px;
      color: #333;
    }

    .file-selector p {
      margin-bottom: 20px;
      color: #666;
    }

    .file-selector input[type="file"] {
      margin-bottom: 15px;
    }

    .file-selector button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
    }

    .file-selector button:hover {
      background: #45a049;
    }

    .file-selector button:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }

    .legend {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: white;
      padding: 15px;
      border-radius: 5px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      max-width: 250px;
      z-index: 1000;
    }

    .legend h4 {
      margin: 0 0 10px 0;
      font-size: 14px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin: 5px 0;
      font-size: 12px;
    }

    .legend-color {
      width: 20px;
      height: 15px;
      margin-right: 8px;
      border: 1px solid #ccc;
    }
  </style>
</head>

<body>
  <div class="viewer-container">
    <div id="map"></div>
    <div id="loading" class="loading-overlay">
      <div class="file-selector">
        <h3>Select Land Cover Export Folder</h3>
        <p>Choose the extracted {aoi}_land_cover_export folder:</p>
        <input type="file" webkitdirectory id="folder-input" />
        <br>
        <button id="load-button" onclick="viewer.loadFromSelectedFolder()" disabled>Load Land Cover Data</button>
      </div>
    </div>
    <div id="legend" class="legend" style="display: none">
      <h4>Land Cover Types</h4>
      <div id="legend-items"></div>
    </div>
    <div id="export-controls" class="export-controls" style="display: none">
      <button id="export-image-btn" onclick="viewer.exportAsImage(4)">
        Export as Image (4x)
      </button>
      <button id="export-image-btn-2x" onclick="viewer.exportAsImage(2)">
        Export as Image (2x)
      </button>
    </div>
  </div>

  <script>
    class LandCoverViewer {
      constructor() {
        this.map = null;
        this.pixelMapping = null;
        this.colorMapping = null;
        this.georaster = null;
      }

      async initialize() {
        try {
          this.map = L.map("map").setView([12.0, 79.8], 10);
          L.tileLayer(
            "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
            {
              attribution: "Tiles © Esri",
              maxZoom: 19,
            }
          ).addTo(this.map);
          this.setupFileSelector();
        } catch (error) {
          console.error("Failed to initialize viewer:", error);
          this.showError(error.message);
        }
      }

      setupFileSelector() {
        const folderInput = document.getElementById("folder-input");
        const loadButton = document.getElementById("load-button");
        folderInput.addEventListener("change", (e) => {
          const files = e.target.files;
          loadButton.disabled = !files || files.length === 0;
        });
      }

      async loadFromSelectedFolder() {
        const folderInput = document.getElementById("folder-input");
        const files = folderInput.files;
        if (!files || files.length === 0) {
          this.showError("No folder selected");
          return;
        }
        try {
          document.getElementById("loading").innerHTML = "Loading land cover data...";
          await this.loadMappingFilesFromFolder(files);
          await this.loadGeotiffFromFolder(files);
          this.createLandCoverLayer();
          this.createLegend();
          this.hideLoading();
        } catch (error) {
          console.error("Failed to load from folder:", error);
          this.showError(error.message);
        }
      }

      async loadMappingFilesFromFolder(files) {
        try {
          const fileArray = Array.from(files);
          const pixelMappingFile = fileArray.find(f => f.name === "pixel-mapping.json");
          const colorMappingFile = fileArray.find(f => f.name === "land-cover-colors.json");
          if (!pixelMappingFile || !colorMappingFile) {
            throw new Error("Required mapping files not found in selected folder");
          }
          const pixelMappingText = await this.readFileAsText(pixelMappingFile);
          const colorMappingText = await this.readFileAsText(colorMappingFile);
          this.pixelMapping = JSON.parse(pixelMappingText);
          this.colorMapping = JSON.parse(colorMappingText);
          console.log("✅ Mapping files loaded from selected folder");
        } catch (error) {
          throw new Error(`Failed to load mapping files: ${error.message}`);
        }
      }

      async loadGeotiffFromFolder(files) {
        try {
          const fileArray = Array.from(files);
          const geotiffFile = fileArray.find(f => f.name === "land-cover_cog.tif");
          if (!geotiffFile) {
            throw new Error("land-cover_cog.tif not found in selected folder");
          }
          const arrayBuffer = await this.readFileAsArrayBuffer(geotiffFile);
          this.georaster = await parseGeoraster(arrayBuffer);
          console.log("✅ Geotiff loaded from selected folder");
        } catch (error) {
          throw new Error(`Failed to load geotiff: ${error.message}`);
        }
      }

      readFileAsText(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => resolve(e.target.result);
          reader.onerror = (e) => reject(new Error("Failed to read file"));
          reader.readAsText(file);
        });
      }

      readFileAsArrayBuffer(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => resolve(e.target.result);
          reader.onerror = (e) => reject(new Error("Failed to read file"));
          reader.readAsArrayBuffer(file);
        });
      }

      createLandCoverLayer() {
        const layer = new GeoRasterLayer({
          georaster: this.georaster,
          opacity: 0.8,
          pixelValuesToColorFn: (pixelValues) =>
            this.mapPixelToColor(pixelValues),
          resolution: 256,
        });
        layer.addTo(this.map);
        if (this.georaster.bounds) {
          const bounds = [
            [this.georaster.bounds[1], this.georaster.bounds[0]], // [south, west]
            [this.georaster.bounds[3], this.georaster.bounds[2]], // [north, east]
          ];
          this.map.fitBounds(bounds);
        }
      }

      mapPixelToColor(pixelValues) {
        if (
          !pixelValues ||
          pixelValues.length === 0 ||
          pixelValues[0] === null ||
          pixelValues[0] === -1
        ) {
          return null;
        }
        const pixelValue = pixelValues[0];
        const landCoverClass = this.pixelMapping[pixelValue];
        if (!landCoverClass) {
          return null;
        }
        return this.getColorForLandCover(landCoverClass);
      }

      getColorForLandCover(landCoverPath) {
        if (this.colorMapping[landCoverPath]) {
          return this.colorMapping[landCoverPath];
        }
        const pathParts = landCoverPath.split(".");
        while (pathParts.length > 0) {
          pathParts.pop();
          const parentPath = pathParts.join(".");
          if (this.colorMapping[parentPath]) {
            return this.colorMapping[parentPath];
          }
        }
        return "#888888";
      }

      createLegend() {
        const legendContainer = document.getElementById("legend-items");
        const usedLandCovers = new Set(Object.values(this.pixelMapping));
        const legendItems = Array.from(usedLandCovers)
          .map((landCover) => ({
            landCover,
            color: this.getColorForLandCover(landCover),
            displayName: this.getDisplayName(landCover),
          }))
          .sort((a, b) => a.displayName.localeCompare(b.displayName));
        legendContainer.innerHTML = legendItems
          .map(
            (item) => `
              <div class="legend-item">
                <div class="legend-color" style="background-color: ${item.color}"></div>
                <span>${item.displayName}</span>
              </div>
            `
          )
          .join("");
        document.getElementById("legend").style.display = "block";
        document.getElementById("export-controls").style.display = "block";
      }

      getDisplayName(landCoverPath) {
        return landCoverPath.split(".").pop().replace(/_/g, " ");
      }

      hideLoading() {
        document.getElementById("loading").classList.add("hidden");
      }

      showError(message) {
        document.getElementById("loading").innerHTML = `<div class="file-selector"><h3>Error</h3><p>${message}</p><button onclick="location.reload()">Reload</button></div>`;
      }

      async exportAsImage(scaleFactor = 4) {
        if (!this.georaster || !this.pixelMapping) {
          alert('No data loaded for export');
          return;
        }
        const sourceWidth = this.georaster.width;
        const sourceHeight = this.georaster.height;
        const outputWidth = sourceWidth * scaleFactor;
        const outputHeight = sourceHeight * scaleFactor;
        const canvas = document.createElement('canvas');
        canvas.width = outputWidth;
        canvas.height = outputHeight;
        const ctx = canvas.getContext('2d');
        const imageData = ctx.createImageData(outputWidth, outputHeight);
        const data = imageData.data;
        console.log(`Generating ${outputWidth}x${outputHeight} image...`);
        for (let y = 0; y < sourceHeight; y++) {
          for (let x = 0; x < sourceWidth; x++) {
            const pixelValue = this.georaster.values[0][y][x];
            const landCoverClass = this.pixelMapping[pixelValue];
            let color = '#000000';
            if (landCoverClass && landCoverClass !== 'unlabeled') {
              color = this.getColorForLandCover(landCoverClass);
            } else if (pixelValue === -1) {
              color = null;
            }
            let r = 0, g = 0, b = 0, a = 255;
            if (color) {
              const hex = color.replace('#', '');
              r = parseInt(hex.substr(0, 2), 16);
              g = parseInt(hex.substr(2, 2), 16);
              b = parseInt(hex.substr(4, 2), 16);
            } else {
              a = 0;
            }
            for (let dy = 0; dy < scaleFactor; dy++) {
              for (let dx = 0; dx < scaleFactor; dx++) {
                const outputX = x * scaleFactor + dx;
                const outputY = y * scaleFactor + dy;
                const index = (outputY * outputWidth + outputX) * 4;
                data[index] = r;     // red
                data[index + 1] = g; // green
                data[index + 2] = b; // blue
                data[index + 3] = a; // alpha
              }
            }
          }
        }
        ctx.putImageData(imageData, 0, 0);
        canvas.toBlob((blob) => {
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = `land-cover-${outputWidth}x${outputHeight}.png`;
          link.click();
          URL.revokeObjectURL(link.href);
          console.log(`✅ Exported ${outputWidth}x${outputHeight} image`);
        }, 'image/png');
      }
    }

    let viewer;
    document.addEventListener("DOMContentLoaded", async () => {
      viewer = new LandCoverViewer();
      await viewer.initialize();
    });
  </script>
</body>

</html>