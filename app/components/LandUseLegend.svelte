<script>
  import { getContext } from "svelte";
  import { LandUseHierarchy } from "../js/land-use-hierarchy.js";

  const { dataLoader } = getContext("managers");
  const labeledLayerContext = getContext("labeledLayer");
  let labeledLayer = $derived(labeledLayerContext?.instance);
  let { clusterLabels, onLabelChange } = $props();
  let hierarchyLevel = $state(1);
  let isExporting = $state(false);
  let fileInput = $state();
  const hierarchyLabels = {
    1: "Broad Categories",
    2: "General Types",
    3: "Specific Uses",
    4: "Detailed Classification",
  };
  let hierarchyLabelText = $derived(
    hierarchyLabels[hierarchyLevel] || `Level ${hierarchyLevel}`
  );
  let labeledPaths = $derived(extractLabeledPaths(clusterLabels || {}));
  let displayItems = $derived(
    LandUseHierarchy.isLoaded() && labeledPaths.size > 0
      ? computeDisplayItems(labeledPaths, hierarchyLevel)
      : []
  );
  $effect(() => {
    if (labeledLayer) {
      labeledLayer.setHierarchyLevel(hierarchyLevel);
    }
  });

  function saveLabels() {
    const dataStr = JSON.stringify(clusterLabels, null, 2);
    const dataBlob = new Blob([dataStr], { type: "application/json" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(dataBlob);
    link.download = `cluster-labels-${new Date().toISOString().split("T")[0]}.json`;
    link.click();
    console.log("✅ Labels saved to file:", clusterLabels);
  }

  function loadLabelsFromFile() {
    fileInput.click();
  }

  async function handleFileLoad(event) {
    const file = event.target.files[0];
    if (!file) return;
    try {
      const text = await file.text();
      const loadedLabels = JSON.parse(text);
      console.log("📁 Loading labels from file:", loadedLabels);
      const isValidFormat = Object.entries(loadedLabels).every(
        ([segKey, labels]) => {
          return typeof labels === "object" && !Array.isArray(labels);
        }
      );
      if (!isValidFormat) {
        throw new Error("Invalid label file format");
      }
      if (onLabelChange) {
        onLabelChange(null, null, null, loadedLabels);
      }
      event.target.value = "";
    } catch (error) {
      console.error("Failed to load labels file:", error);
      alert(`Failed to load labels: ${error.message}`);
    }
  }

  function clearAllLabels() {
    if (!confirm("Clear all cluster labels for ALL segmentations?")) return;
    if (onLabelChange) {
      onLabelChange(null, null, null, {});
    }
    console.log("✅ All labels cleared");
  }

  async function handleExport() {
    if (!labeledLayer) {
      alert("No labeled layer available for export");
      return;
    }
    const stats = labeledLayer.getStats();
    if (stats.totalLabels === 0) {
      alert(
        "No labeled clusters available for export. Please label some clusters first."
      );
      return;
    }
    if (!stats.isVisible) {
      alert(
        "Labeled regions layer is not visible. Please enable it first to generate composite."
      );
      return;
    }
    try {
      isExporting = true;
      const { ExportUtility } = await import("../js/export-utility.js");
      const exporter = new ExportUtility(labeledLayer, dataLoader);
      await exporter.exportLandCoverFiles();
      alert("Land cover files exported successfully!");
    } catch (error) {
      console.error("Export failed:", error);
      alert(`Export failed: ${error.message}`);
    } finally {
      isExporting = false;
    }
  }

  function handleHierarchyLevelChange(event) {
    hierarchyLevel = parseInt(event.target.value);
  }

  function extractLabeledPaths(allLabels) {
    const paths = new Set();
    if (!allLabels || typeof allLabels !== "object") {
      return paths;
    }
    Object.entries(allLabels).forEach(
      ([segmentationKey, segmentationLabels]) => {
        if (segmentationLabels && typeof segmentationLabels === "object") {
          Object.entries(segmentationLabels).forEach(
            ([clusterId, landUsePath]) => {
              if (landUsePath && landUsePath !== "unlabeled") {
                paths.add(landUsePath);
              }
            }
          );
        }
      }
    );
    return paths;
  }

  function computeDisplayItems(labeledPaths, targetLevel) {
    if (!LandUseHierarchy.isLoaded() || labeledPaths.size === 0) {
      return [];
    }
    const hierarchy = LandUseHierarchy.getInstance();
    const relevantPaths = getRelevantPathsForLevel(labeledPaths, targetLevel);
    const items = [];
    const hierarchyItems = hierarchy.getHierarchyItemsAtLevel(targetLevel);
    for (const item of hierarchyItems) {
      if (relevantPaths.has(item.path)) {
        items.push(item);
      }
    }
    for (const path of relevantPaths) {
      const pathParts = path.split(".");
      if (pathParts.length < targetLevel) {
        const existing = items.find((item) => item.path === path);
        if (!existing) {
          const color = hierarchy.getColorForPath(path);
          items.push({
            path: path,
            name: pathParts[pathParts.length - 1],
            displayPath: pathParts.join(" > "),
            color: color ? `#${color.replace("#", "")}` : "#888888",
            isPromoted: true,
          });
        }
      }
    }
    return items.sort((a, b) => compareHierarchicalPaths(a.path, b.path));
  }

  function getRelevantPathsForLevel(labeledPaths, targetLevel) {
    const relevantPaths = new Set();
    for (const path of labeledPaths) {
      const pathParts = path.split(".");
      if (pathParts.length === targetLevel) {
        relevantPaths.add(path);
      } else if (pathParts.length > targetLevel) {
        const parentPath = pathParts.slice(0, targetLevel).join(".");
        relevantPaths.add(parentPath);
      } else if (pathParts.length < targetLevel) {
        relevantPaths.add(path);
      }
    }
    return relevantPaths;
  }

  function compareHierarchicalPaths(pathA, pathB) {
    const partsA = pathA.split(".");
    const partsB = pathB.split(".");
    const maxLength = Math.max(partsA.length, partsB.length);
    for (let i = 0; i < maxLength; i++) {
      const partA = partsA[i] || "";
      const partB = partsB[i] || "";
      if (partA !== partB) {
        return partA.localeCompare(partB);
      }
    }
    return partsA.length - partsB.length;
  }

  let promotedCount = $derived(
    displayItems.filter((item) => item.isPromoted).length
  );
  let regularCount = $derived(displayItems.length - promotedCount);
  let statsText = $derived(
    `${regularCount} categories${promotedCount > 0 ? `, ${promotedCount} promoted` : ""}`
  );
</script>

<div
  class="land-use-legend"
  role="region"
  aria-labelledby="landuse-legend-title"
>
  <div class="legend-header">
    <h3 id="landuse-legend-title">Land Use Classification</h3>
  </div>
  <div class="label-management-controls">
    <div class="label-controls-row">
      <button
        class="label-btn"
        onclick={loadLabelsFromFile}
        aria-describedby="load-labels-desc"
      >
        Load Labels
      </button>
      <input
        bind:this={fileInput}
        type="file"
        accept=".json"
        style="display: none"
        onchange={handleFileLoad}
      />
      <button
        class="label-btn"
        onclick={saveLabels}
        aria-describedby="save-labels-desc"
      >
        Save Labels
      </button>
      <button
        class="label-btn secondary"
        onclick={clearAllLabels}
        aria-describedby="clear-labels-desc"
      >
        Clear All
      </button>
    </div>
    <div class="legend-stats" aria-live="polite">
      <span>{labeledPaths.size > 0 ? statsText : "No labeled regions"}</span>
    </div>
  </div>
  <div class="layer-control-group">
    <div class="hierarchy-control">
      <label for="hierarchy-level-slider">Detail Level:</label>
      <input
        type="range"
        id="hierarchy-level-slider"
        min="1"
        max="4"
        step="1"
        value={hierarchyLevel}
        oninput={handleHierarchyLevelChange}
        aria-describedby="hierarchy-level-desc"
      />
      <span id="hierarchy-level-desc">{hierarchyLabelText}</span>
    </div>
    <div class="export-control">
      <button
        class="export-btn"
        class:loading={isExporting}
        disabled={isExporting || displayItems.length === 0}
        onclick={handleExport}
        aria-describedby="export-btn-desc"
      >
        {isExporting ? "Exporting..." : "Export Land Cover"}
      </button>
      <span id="export-btn-desc" class="sr-only">
        Export labeled regions as GeoTIFF and mapping files
      </span>
    </div>
  </div>
  <div
    class="legend-items-container"
    role="list"
    aria-labelledby="landuse-items-title"
  >
    <span id="landuse-items-title" class="sr-only">
      Land use categories currently in use
    </span>
    {#if displayItems.length === 0}
      <div class="legend-placeholder" role="status">
        {labeledPaths.size === 0
          ? "No labeled regions to display"
          : "No items at this hierarchy level"}
      </div>
    {:else}
      {#each displayItems as item (item.path)}
        <div
          class="landuse-legend-item"
          class:promoted={item.isPromoted}
          role="listitem"
          data-path={item.path}
        >
          <div
            class="landuse-color-swatch"
            style="background-color: {item.color}"
            aria-hidden="true"
          ></div>
          <div class="landuse-text">
            <span class="landuse-name">{item.name}</span>
            <span class="landuse-path">{item.displayPath}</span>
            {#if item.isPromoted}
              <span
                class="promoted-indicator"
                aria-label="Promoted from deeper level">↑</span
              >
            {/if}
          </div>
        </div>
      {/each}
    {/if}
  </div>
</div>

<style>
  .land-use-legend {
    display: flex;
    flex-direction: column;
    height: 100%;
  }

  .legend-header {
    flex-shrink: 0;
    padding: 16px;
    border-bottom: 1px solid #eee;
    background: #f8f9fa;
  }

  .legend-header h3 {
    margin: 0;
    font-size: 18px;
    font-weight: 600;
    color: #222;
  }

  .label-management-controls {
    padding: 12px 16px;
    border-bottom: 1px solid #eee;
    background: #fafafa;
  }

  .label-controls-row {
    display: flex;
    gap: 8px;
    margin-bottom: 8px;
    flex-wrap: wrap;
  }

  .label-btn {
    padding: 8px 12px;
    font-size: 14px;
    border: 1px solid #007bff;
    background: #007bff;
    color: white;
    border-radius: 4px;
    cursor: pointer;
    flex: 1;
    min-width: 80px;
    font-weight: 500;
    transition: all 0.2s ease;
  }

  .label-btn:hover {
    background: #0056b3;
    border-color: #0056b3;
  }

  .label-btn:focus {
    outline: 2px solid #007bff;
    outline-offset: 2px;
  }

  .label-btn.secondary {
    background: #6c757d;
    border-color: #6c757d;
  }

  .label-btn.secondary:hover {
    background: #5a6268;
    border-color: #545b62;
  }

  .legend-stats {
    color: #666;
    font-size: 13px;
    font-weight: 500;
    text-align: center;
  }

  .layer-control-group {
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 15px;
    border-bottom: 1px solid #eee;
  }

  .hierarchy-control {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .hierarchy-control label {
    font-size: 12px;
    font-weight: 600;
    color: #333;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .hierarchy-control input[type="range"] {
    width: 100%;
    margin: 2px 0;
  }

  .hierarchy-control span {
    font-size: 11px;
    color: #666;
    font-style: italic;
  }

  .export-control {
    display: flex;
    flex-direction: column;
    gap: 5px;
  }

  .export-btn {
    padding: 8px 12px;
    border: 1px solid #28a745;
    background: #28a745;
    color: white;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 500;
    transition: all 0.2s ease;
  }

  .export-btn:hover:not(:disabled) {
    background: #218838;
  }

  .export-btn:focus {
    outline: 2px solid #28a745;
    outline-offset: 2px;
  }

  .export-btn:disabled {
    background: #6c757d;
    border-color: #6c757d;
    cursor: not-allowed;
    opacity: 0.6;
  }

  .export-btn.loading {
    background: #ffc107;
    border-color: #ffc107;
    color: #212529;
  }

  .legend-items-container {
    flex: 1;
    overflow-y: auto;
    border: 1px solid #eee;
    border-radius: 4px;
    margin: 0 15px 15px;
  }

  .legend-placeholder {
    text-align: center;
    color: #999;
    padding: 20px;
    font-style: italic;
    font-size: 12px;
  }

  .landuse-legend-item {
    display: flex;
    align-items: center;
    padding: 8px 12px;
    border-bottom: 1px solid #f0f0f0;
    gap: 10px;
  }

  .landuse-legend-item:last-child {
    border-bottom: none;
  }

  .landuse-legend-item.promoted {
    background-color: #fff3cd;
  }

  .landuse-color-swatch {
    width: 20px;
    height: 15px;
    border: 1px solid #ccc;
    border-radius: 2px;
    flex-shrink: 0;
  }

  .landuse-text {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .landuse-name {
    font-weight: bold;
    font-size: 12px;
    color: #333;
  }

  .landuse-path {
    font-size: 10px;
    color: #666;
  }

  .promoted-indicator {
    font-size: 12px;
    color: #856404;
    font-weight: bold;
  }

  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  /* Responsive design */
  @media (max-width: 900px) {
    .label-controls-row {
      flex-direction: column;
    }

    .label-btn {
      flex: none;
      width: 100%;
    }
  }

  /* High contrast mode support */
  @media (prefers-contrast: high) {
    .label-btn {
      border: 2px solid;
    }
  }

  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    .label-btn,
    .export-btn {
      transition: none;
    }
  }
</style>
